{
  "url": "https://api.github.com/repos/rust-lang/rust/issues/comments/526118914",
  "html_url": "https://github.com/rust-lang/rust/issues/63997#issuecomment-526118914",
  "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/63997",
  "id": 526118914,
  "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjExODkxNA==",
  "user": {
    "login": "gnzlbg",
    "id": 904614,
    "node_id": "MDQ6VXNlcjkwNDYxNA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/904614?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gnzlbg",
    "html_url": "https://github.com/gnzlbg",
    "followers_url": "https://api.github.com/users/gnzlbg/followers",
    "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}",
    "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions",
    "organizations_url": "https://api.github.com/users/gnzlbg/orgs",
    "repos_url": "https://api.github.com/users/gnzlbg/repos",
    "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gnzlbg/received_events",
    "type": "User",
    "site_admin": false
  },
  "created_at": "2019-08-29T10:07:04Z",
  "updated_at": "2019-08-29T10:14:44Z",
  "author_association": "CONTRIBUTOR",
  "body": "I think that, at the very least, this should work:\r\n\r\n```rust\r\nconst fn foo() {}\r\nconst FOO: const fn() = foo;\r\nconst fn bar() { FOO() }\r\nconst fn baz(x: const fn()) { x() }\r\nconst fn bazz() { baz(FOO) }\r\n```\r\n\r\nFor this to work:\r\n\r\n* `const` must be part of `fn` types (just like `unsafe`, the `extern \"ABI\"`, etc.)\r\n* we should allow calling `const fn` types from const fn\r\n\r\nCurrently, `const fn`s already coerce to `fn`s, so `const fn` types should too:\r\n\r\n```rust\r\nconst fn foo() {}\r\nlet x: const fn() = foo;\r\nlet y: fn() = x; // OK: const fn => fn coercion\r\n```\r\n\r\nI don't see any problems with supporting this. The RFC mentions some issues, but I don't see anything against just supporting this restricted subset.\r\n\r\nThis subset would be **super** useful. For example, you could do:\r\n\r\n```rust\r\nstruct Foo<T>(T);\r\ntrait Bar { const F: const fn(Self) -> Self; }\r\n\r\nimpl<T: Bar> Foo<T> {\r\n    const fn new(x: T) -> Self { Foo(<T as Bar>::F(x)) }\r\n}\r\n\r\nconst fn map_i32(x: i32) -> i32 { x * 2 }\r\nimpl Bar for i32 { const F: const fn(Self) -> Self = map_i32; } \r\nconst fn map_u32(x: i32) -> i32 { x * 3 }\r\nimpl Bar for u32 { const F: const fn(Self) -> Self = map_u32; } \r\n```\r\n\r\nwhich is a quite awesome work around for the lack of `const` trait methods, but much simpler since dynamic dispatch isn't an issue, as opposed to: \r\n\r\n```rust\r\ntrait Bar { const fn map(self) -> Self; } \r\nimpl Bar for i32 { ... }\r\nimpl Bar for u32 { ... }\r\n// or const impl Bar for i32 { ... {\r\n```\r\n\r\nThis is also a way to avoid having to use `if`/`match` etc. in `const fn`s, since you can create a trait with a const, and just dispatch on it to achieve \"conditional\" control-flow at least at compile-time."
}
